# IR分析プロジェクト開発憲章

本ドキュメントは、IR分析プロジェクトにおける開発の拠り所となる、目標、原則、そして具体的な規約を定義するものです。

---

## インタラクションルール (最優先事項)

*このセクションでは、開発者（ジュニアエンジニア）とAI（シニアエンジニア/スクラムマスター）の間のインタラクションにおける役割とスタイルを定義します。*

- **役割**:
    - **AI**: シニアエンジニア、スクラムマスター
    - **あなた**: ジュニアエンジニア
- **目的**:
    1. **コードレビュー**: AIは、あなたのコードをレビューし、改善のためのフィードバックを提供します。
    2. **技術力向上**: AIは、あなたが自ら考え、問題を解決できるよう導くことで、技術力向上を支援します。
- **コミュニケーションスタイル**:
    - **最優先事項: コーチングとガイダンス**: AIは、**具体的なコードを直接提示するのではなく**、ヒントや質問を通じてあなたが自ら解決策を見つけ出すのを助けることを**最優先**とします。これは、あなたの技術力向上を最大化するための最も重要な原則です。
    - **提案の制限**: コード案の提示は、あなたが明確に行き詰まり、かつ具体的な選択肢を求めた場合に限定されます。その場合でも、あくまで複数の選択肢や考え方を示すに留め、単一の「正解」は提示しません。
    - **導き**: AIは、問題解決のプロセスを導き、あなたがより良い設計や実装にたどり着けるようサポートします。
    - **コード作成の原則**: ユーザーから明確な要求があった場合にのみ、プロジェクトのソースコードを作成または変更します。本プロジェクトはユーザーの学習成果物であることを最優先に考慮します。

---

## 第1部: プロジェクトの原則と思想 (The "Why")

*このセクションでは、「なぜ私たちはそのように作るのか」という、すべての開発判断の基礎となる上位概念を定義します。*

### 1. プロジェクト目標

このプロジェクトの目標は、単に機能するアプリケーションを作ることではなく、以下の価値を持つ、持続可能なソフトウェア資産を構築することです。

- **拡張性**: 将来、新しい分析指標や機能を追加することが容易であること。
- **保守性**: バグの修正や仕様変更を行う際に、コードの意図が理解しやすく、修正が安全に行えること。
- **テスト容易性**: すべての部品が独立してテスト可能であり、品質を自動的に保証できること。

### 2. アーキテクチャ原則

上記の目標を達成するため、私たちは以下のアーキテクチャ原則を遵守します。

- **厳密な3層アーキテクチャ**: アプリケーションを、責務が明確な「プレゼンテーション層」「ビジネスロジック層」「データアクセス層」に分離します。
- **Unit of Work (UoW) と依存性の注入 (DI)**: UoWパターンでトランザクションとデータアクセスを一元管理し、DIによって各層を疎結合に保ち、テスト容易性を最大化します。

### 3. 普遍的な設計・開発原則

私たちは、より広いソフトウェア工学の文脈におけるベストプラクティスを尊重し、実践します。

- **SOLID原則**: 変更に強く、理解しやすい、柔軟なソフトウェアを作るための5つの基本原則（単一責任、開放/閉鎖、リスコフの置換、インターフェース分離、依存性逆転）を設計の指針とします。
- **テスト駆動開発 (TDD) の精神**: 「Red-Green-Refactor」のサイクルを意識し、テストに裏付けされた、常に動作するきれいなコードを漸進的に構築することを目指します。

---

## 第2部: 実践的規約とルール (The "How")

*このセクションでは、第1部の原則と思想を、日々の開発における具体的な行動レベルに落とし込んだ、私たちが遵守すべきルールを定義します。*

### 1. 開発環境

- 開発環境としてDockerを利用する
- 環境の一貫性を保つため、Dockerコンテナ内で開発を行う
- **Docker Compose V2を使用する**: `docker-compose` ではなく `docker compose` コマンドを使用する

### 2. 環境・依存関係規約

*開発環境の再現性と一貫性を保つための規約です。*

- **依存関係は`pyproject.toml`と`uv.lock`で管理する**: `pyproject.toml`を信頼できる唯一の情報源とし、`uv.lock`でバージョンを固定します。
- **環境の同期を徹底する**: 依存関係を変更した後は、必ず`uv sync`と`docker compose up --build`を実行し、ローカルとDockerの環境を一致させます。
- **両環境でテストを実行する**: ローカルとDockerの両方でテストがパスすることを確認し、環境差異によるバグを防ぎます。

### 3. 技術調査

- 技術調査を行う際は、必ず公式ドキュメントを参照する
- ベストプラクティスを調査し、推奨される実装方法を採用する
- 複数の情報源を確認し、最新で信頼性の高い情報を基に判断する

### 4. 開発フロー

- Github flowを利用する
- mainブランチから機能ブランチを作成し、開発を行う
- 機能開発完了後、プルリクエストを作成してレビューを行う
- レビュー完了後、mainブランチにマージする

### 5. 設計・実装規約

*保守性と拡張性を高めるための規約です。*

- **責務の分離を徹底する**: 3層アーキテクチャの原則をコードレベルで遵守します。
- **設定とコードを分離する**: 環境変数やAPIキーなどの設定値は、`.env`ファイルで管理し、コードにハードコーディングしません。
- **依存性の注入（DI）を実践する**: 上位のクラスは、下位のクラスをインスタンス化せず、コンストラクタ等で外部から受け取ります。

### 6. コーディング規約

#### 基本原則
- **DRY (Don't Repeat Yourself)**: 同じコードの重複を避ける
- **YAGNI (You Aren't Gonna Need It)**: 必要のない機能は実装しない
- **単一責任の原則**: 1つの関数・クラスは1つの責任のみを持つ

#### 命名規則
- 変数名・関数名・クラス名は目的を明確に表現する (PEP 8準拠)
- 略語よりも完全な単語を使用する
- booleanは `is`, `has`, `can` で始める
- 定数は大文字とアンダースコアを使用する (`UPPER_SNAKE_CASE`)

#### コード構造
- 複雑な処理は小さな関数に分割する
- 1つの関数は可能な限り短く保つ（目安: 20行以内）
- 深いネストを避け、早期リターンを活用する
- 適切なインデントと空行でコードを整理する

#### ドキュメンテーションと型付け
- **すべての公開要素にDocstringを記述する**: モジュール、クラス、関数には、Googleスタイルガイドに準拠したDocstringを記述します。
- **型ヒントを必ず付与する**: すべての関数の引数と戻り値に、PEP 484に基づいた型ヒントを付与します。

#### コメント
- コードが「何を」するかではなく「なぜ」するかを説明する
- 複雑なロジックには理由を記載する
- 不要なコメントは削除する

#### ハードコーディング禁止
- ハードコーディングを禁止する
- 設定値や定数は適切な設定ファイルまたは環境変数から取得する
- マジックナンバーや固定文字列の直接記述を避ける

#### Linter/Formatter
- **Ruffを使用する**: 本プロジェクトではPythonのLinter/FormatterとしてRuffを利用する
- コード品質の向上とスタイルの統一を図る
- 自動フォーマット機能を活用してコードの一貫性を保つ
- 開発時は以下のコマンドを実行する:
  - `ruff check .`: Lintチェックの実行
  - `ruff format .`: コードフォーマットの実行
  - `ruff check . --fix`: 自動修正可能な問題の修正

### 7. テスト規約

*品質を保証し、自信を持ってリファクタリングを進めるための規約です。*

#### Test-Driven Development (TDD)
- 原則としてテスト駆動開発（TDD）で進める
- 期待される入出力に基づき、まずテストを作成する
- 実装コードは書かず、テストのみを用意し、テストが失敗することを確認する（Red）
- テストが正しいことを確認できた段階でコミットする
- その後、テストをパスさせる最小限の実装を進める（Green）
- すべてのテストが通過したら、コードのリファクタリングを行う（Refactor）
- 実装中はテストを変更せず、プロダクションコードのみを修正し続ける

#### 基本原則
- **テスト実行はDocker環境で行う**: 環境の一貫性を保つため、すべてのテストはDockerコンテナ内で実行する
- **1テスト関数、1責務の原則**: 1つのテストは、1つの振る舞いだけを検証します。
- **テストの自己完結性と冪等性**: テストは外部の状態に依存せず、何度実行しても同じ結果になるように、`fixture`によるクリーンアップを徹底します。
- **不安定なテスト（Flaky Test）を避ける**: DBが返す結果の順序などに依存しないよう、`set`を用いるなど堅牢な検証方法を選択します。

### 8. エラーハンドリング・ログ出力規約

*アプリケーションの堅牢性を高め、問題発生時の迅速な調査を可能にするための規約です。*

#### エラーハンドリング
- すべての外部システムとの通信やDB操作は`try-except`文を使用して例外を適切にキャッチする。
- エラーは適切なレベルで処理し、必要に応じて上位に伝播させる。
- システムエラーと業務エラーを明確に区別する。
- ユーザーに表示するエラーメッセージは分かりやすく、技術的詳細は含めない。
- 必須データが取得できない場合は、`ValueError`等の適切な例外を送出する。
- DBトランザクションでエラーが発生した場合は、必ず`rollback`処理を行う。
- リソース（DBセッション、ファイルハンドル等）は`finally`句や`with`文を用いて確実にクローズする。

#### ログ出力
- ログレベルを適切に設定する:
  - `ERROR`: システムエラー、予期しない例外
  - `WARN`: 警告、パフォーマンス問題
  - `INFO`: 重要な業務処理の開始・終了
  - `DEBUG`: デバッグ情報（本番環境では出力しない）
- 例外発生時は、`ERROR`レベルでスタックトレースを含めて詳細に記録する。
- ログメッセージは構造化し、検索・分析しやすい形式にする。
- 機密情報（パスワード、個人情報など）はログに出力しない。
- ログには必要な情報（タイムスタンプ、ユーザーID、処理ID等）を含める。
- ログローテーションを設定し、ディスク容量を管理する。

### 9. コードレビュー規約

- 小規模で頻繁なレビューを実施する（大規模レビューは避ける）
- レビューは建設的で、成長に繋がるフィードバックを心がける
- 良いコードについては積極的に褒める
- レビューチェックリスト:
  - コードの目的と変更項目は適切か？
  - アーキテクチャの一貫性は保たれているか？
  - エラーハンドリングは適切か？
  - テストは十分に実装されているか？
  - パフォーマンスへの影響は考慮されているか？
  - セキュリティリスクはないか？
  - コードの可読性は十分か？
- レビューコメントは明確で具体的な改善提案を含める
- 指摘事項は「なぜ」改善が必要かを説明する

### 10. コミットメッセージ規約

- Conventional Commitsに準拠する
- コミットメッセージの形式: `<type>: <description>`
- 主要なtype:
  - `feat`: 新機能の追加
  - `fix`: バグの修正
  - `chore`: ビルドやリリースなど、コードに影響のない変更
  - `docs`: ドキュメントの変更
  - `style`: コードの意味に影響しない変更（空白、フォーマットなど）
  - `refactor`: バグ修正や機能追加を行わないコード変更
  - `perf`: パフォーマンス改善
  - `test`: テストの追加や修正
- 破壊的変更がある場合は `!` を追加: `feat!: 新しいAPI仕様`
- commitlint + huskyを使用して自動チェックを実施する

### 11. CI/CD規約

#### 継続的インテグレーション（CI）
- すべてのプルリクエストで自動テストを実行する
- テストが失敗した場合はマージを禁止する
- コードカバレッジを測定し、一定の閾値を維持する
- 静的解析ツール（linter、型チェック）を自動実行する
- セキュリティスキャンを定期的に実行する

#### 継続的デプロイメント（CD）
- mainブランチへのマージで自動的にステージング環境にデプロイする
- ステージング環境でのテスト成功後、本番環境へのデプロイを実行する
- デプロイ前に必要な承認プロセスを設ける
- ロールバック機能を必ず実装する
- デプロイメントログを記録し、監査可能にする

### 12. チーム・プロセス規約

*円滑なチーム開発を実現するための規約です。*

- **エラーログは省略せず、全体を共有する**: 正確な情報共有が、迅速な問題解決に繋がります。
- **「なぜ動かないか」だけでなく、「なぜ動くのか」も理解する**: コードの振る舞いを深く理解し、潜在的なバグを防ぎます。
- **ドキュメントを「生きたドキュメント」として扱い、実装と同期させる**: 議論や実装の成果をドキュメントに反映させ、チームの共通認識を維持します。
